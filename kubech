#
# This script is meant to be sourced in shell config file e.g. ".bashrc" in bash.
#
# Kubech is a simple tool that lets you set contexts/namespaces per shell/terminal.
# That's help you to manage multi Kubernetes cluster at the same time.


#
# Vars.
KUBECONFIG_ORIG="${KUBECONFIG:-$HOME/.kube/config}"
KUBECONFIG_SRC_DIR="${KUBECONFIG_SRC_DIR:-$HOME/.kube/config.src.d}"
KUBECONFIG_DEST_DIR="${KUBECONFIG_DEST_DIR:-$HOME/.kube/config.dest.d}"
KUBECONFIG_ACTIVE=""


#
# Usage.
kubech () {
  cat <<EOF
NOTE:
  - The command "kubech" is just a meta for other commands. So kubech does nothing by itself.
  - Also short names like "kchc/kchn/kchu" are available.

VARS:
  KUBECONFIG_SRC_DIR  : Set directory with extra kubectl config files to read in kubech commands.
                        This allow to have multiple config files in addition to
                        the one at "\$HOME/.kube/config".
                        Default: "${KUBECONFIG_SRC_DIR}"
  KUBECONFIG_DEST_DIR : Set directory for temporary kubectl config files. The files
                        in this directory are auto-generated by kubech commands
                        and you don't need to interact with them or even change that var.
                        Default: "${KUBECONFIG_DEST_DIR}"

USAGE:
  kubechc             : List all contexts
  kubechc <CONTEXT>   : Switch to context <CONTEXT>
  kubechn             : List all namespaces
  kubechn <NAMESPACE> : Switch to namespace <NAMESPACE>
  kubechu             : Unset the active context. This is just a safty net
                        to avoid applying config by mistake to the wrong cluster.
EOF
}


#
# General.

# Create config dirs.
mkdir -p "${KUBECONFIG_SRC_DIR}" "${KUBECONFIG_DEST_DIR}"
chmod 744 "${KUBECONFIG_SRC_DIR}" "${KUBECONFIG_DEST_DIR}"


#
# Handeling Kube config files.
_kubeconfig_files () {
    if [ -d "${KUBECONFIG_SRC_DIR}" ]; then
        case "$(uname -s)" in
            Linux*)
                KUBECONFIG_FILES="$(find "${KUBECONFIG_SRC_DIR}" -type f -printf '%p:')"
                ;;
            Darwin*)
                KUBECONFIG_FILES="$(find "${KUBECONFIG_SRC_DIR}" -type f -print0 | xargs -0 stat -f '%N')"
                ;;
            *)
                echo "UNKNOWN OS:$(uname -s)"
                exit 1
        esac
    fi
    echo "${KUBECONFIG_FILES}${KUBECONFIG_ORIG}"
}

_kube_config () {
    KUBECONFIG_DEFAULT="$(_kubeconfig_files)"
    if [ -n "${1}" ]; then
        if [[ "${KUBECONFIG}" == "${KUBECONFIG_ACTIVE}" ]]; then
            export KUBECONFIG="${1}:${KUBECONFIG_DEFAULT}"
        else
            export KUBECONFIG="${1}:${KUBECONFIG}:${KUBECONFIG_DEFAULT}"
        fi
        KUBECONFIG_ACTIVE="${KUBECONFIG}"

    elif [ -n "${KUBECONFIG}" ]; then
        KUBECONFIG_ACTIVE="${KUBECONFIG}:${KUBECONFIG_DEFAULT}"
        echo "${KUBECONFIG_ACTIVE}"

    else
        KUBECONFIG_ACTIVE="${KUBECONFIG_DEFAULT}:${KUBECONFIG_ORIG}"
        echo "${KUBECONFIG_ACTIVE}"
    fi
}


#
# Generate kubectl config for a single context.
_kubechg () {
    kube_context="${1}"
    if [[ ${kube_context} =~ "/" || ${kube_context} =~ ":" ]]; then
        kube_context=${kube_context//\//@}
        kube_context=${kube_context//:/_}
    fi

    kube_namespace="${2:-default}"
    kubeconfig_file="${kube_context}-${kube_namespace}"

    touch "${KUBECONFIG_DEST_DIR}/${kubeconfig_file}"
    chmod 600 "${KUBECONFIG_DEST_DIR}/${kubeconfig_file}"

    KUBECONFIG="$(_kube_config)"    \
    kubectl config view             \
        --minify                    \
        --flatten                   \
        --context="${kube_context}" > \
        "${KUBECONFIG_DEST_DIR}/${kubeconfig_file}"
}


#
# Change kubectl context.
kubechc () {
    kube_context="${1}"
    kube_namespace="${2:-default}"

    if [[ -n "${kube_context}" ]]; then
        _kubechg "${kube_context}" "${kube_namespace}"
        _kube_config "${KUBECONFIG_DEST_DIR}/${kube_context}-${kube_namespace}"
        # kubectl config current-context
    else
        KUBECONFIG=$(_kube_config) kubectl config get-contexts --no-headers=true -o name
    fi
}

alias kctx='kubechc'


#
# Change kubectl namespace
kubechn () {
    kube_namespace="${1:-default}"
    kube_namespace_all=$(kubectl get namespaces -o=jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}')

    if [[ -n ${1} ]]; then
        # Only switch namespace if it exists.
        if echo "${kube_namespace_all}" | grep -qE "^${kube_namespace}$"; then
            kubechc "$(kubectl config current-context)" "${kube_namespace}"
            kubectl config set-context --current --namespace="${kube_namespace}"
            echo "Switched to namespace \"${kube_namespace}\""
        else
            echo "The namespace \"${kube_namespace}\" doesn't exist"
        fi
    else
        echo "${kube_namespace_all}"
    fi
}

alias kns='kubechn'


#
# Unset the active context.
kubechu () {
    kubectl config unset current-context
}

alias kchu='kubechu'
