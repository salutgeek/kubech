#
# This script is meant to be sourced in shell config file e.g. ".bashrc" in bash.
#
# Kubech is a simple tool that lets you set contexts/namespaces per shell/terminal.
# That's help you to manage multi Kubernetes cluster at the same time.


#
# Vars.
KUBECONFIG_ORIG="${KUBECONFIG:-$HOME/.kube/config}"
KUBECONFIG_SRC_DIR="${KUBECONFIG_SRC_DIR:-$HOME/.kube/config.src.d}"
KUBECONFIG_DEST_DIR="${KUBECONFIG_DEST_DIR:-$HOME/.kube/config.dest.d}"
KUBECONFIG_ACTIVE=""


#
# Usage.
kubech () {
  cat <<EOF
NOTE:
  - The command "kubech" is just a meta for other commands. So kubech does nothing by itself.
  - Also short names like "kctx/kns/kundo" are available.

VARS:
  KUBECONFIG_SRC_DIR  : Set directory with extra kubectl config files to read in kubech commands.
                        This allow to have multiple config files in addition to
                        the one at "\$HOME/.kube/config".
                        Default: "${KUBECONFIG_SRC_DIR}"
  KUBECONFIG_DEST_DIR : Set directory for temporary kubectl config files. The files
                        in this directory are auto-generated by kubech commands
                        and you don't need to interact with them or even change that var.
                        Default: "${KUBECONFIG_DEST_DIR}"

USAGE:
  kctx                : List all contexts
  kctx <CONTEXT>      : Switch to context <CONTEXT>
  kns                 : List all namespaces
  kns <NAMESPACE>     : Switch to namespace <NAMESPACE>
  kundo               : Unset the active context. This is just a safty net
                        to avoid applying config by mistake to the wrong cluster.
EOF
}


#
# General.

# Create config dirs.
mkdir -p "${KUBECONFIG_SRC_DIR}" "${KUBECONFIG_DEST_DIR}"
chmod 744 "${KUBECONFIG_SRC_DIR}" "${KUBECONFIG_DEST_DIR}"


# Handeling Kube config files.
_kubeconfig_files () {
    if [ -d "${KUBECONFIG_SRC_DIR}" ]; then
        case "$(uname -s)" in
            Linux*)
                KUBECONFIG_FILES="$(find "${KUBECONFIG_SRC_DIR}" -type f -printf '%p:')"
                ;;
            Darwin*)
                KUBECONFIG_FILES="$(find "${KUBECONFIG_SRC_DIR}" -type f -print0 | xargs -0 stat -f '%N')"
                ;;
            *)
                echo "UNKNOWN OS:$(uname -s)"
                exit 1
        esac
    fi
    echo "${KUBECONFIG_FILES}${KUBECONFIG_ORIG}"
}


# Change value of KUBECONFIG variable
# if $1 existe, append $1 to prefix of KUBECONFIG
_kubeconfig_append () {
    KUBECONFIG_DEFAULT="$(_kubeconfig_files)"
    if [ -n "${1}" ]; then
        if [[ "${KUBECONFIG}" == "${KUBECONFIG_ACTIVE}" ]]; then
            export KUBECONFIG="${1}:${KUBECONFIG_DEFAULT}"
        else
            export KUBECONFIG="${1}:${KUBECONFIG}:${KUBECONFIG_DEFAULT}"
        fi
        KUBECONFIG_ACTIVE="${KUBECONFIG}"

    elif [ -n "${KUBECONFIG}" ]; then
        KUBECONFIG_ACTIVE="${KUBECONFIG}:${KUBECONFIG_DEFAULT}"
        echo "${KUBECONFIG_ACTIVE}"

    else
        KUBECONFIG_ACTIVE="${KUBECONFIG_DEFAULT}:${KUBECONFIG_ORIG}"
        echo "${KUBECONFIG_ACTIVE}"
    fi
}

# Create a temporary kubeconfig file
_kubeconfig_tmp () {
    local kube_context="${1}"
    local kube_namespace="${2:-default}"

    # create tmp variable to sanitize kube_context's name if it contains / or :
    local kube_context_tmp=${kube_context}
    if [[ ${kube_context_tmp} =~ "/" || ${kube_context_tmp} =~ ":" ]]; then
        kube_context_tmp=${kube_context_tmp//\//@}
        kube_context_tmp=${kube_context_tmp//:/_}
    fi

    local kubeconfig_file="${kube_context_tmp}-${kube_namespace}"

    touch "${KUBECONFIG_DEST_DIR}/${kubeconfig_file}"
    chmod 600 "${KUBECONFIG_DEST_DIR}/${kubeconfig_file}"

    # write contents of first kubeconfig in KUBECONFIG to a tmp kubeconfig file
    KUBECONFIG="$(_kubeconfig_append)"    \
    kubectl config view             \
        --minify                    \
        --flatten                   \
        --context="${kube_context}" > \
        "${KUBECONFIG_DEST_DIR}/${kubeconfig_file}"
}

# Switch kube context
kctx () {
    local kube_context="${1}"
    local kube_namespace="${2:-default}"

    # create tmp variable to sanitize kube_context's name if it contains / or :
    local kube_context_tmp=${kube_context}
    if [[ ${kube_context_tmp} =~ "/" || ${kube_context_tmp} =~ ":" ]]; then
        kube_context_tmp=${kube_context_tmp//\//@}
        kube_context_tmp=${kube_context_tmp//:/_}
    fi

    local kubeconfig_file="${kube_context_tmp}-${kube_namespace}"

    if [[ -n "${kube_context}" ]]; then
        # Only switch context if context exists.
        if echo "$(kubectl config get-contexts --no-headers=true -o name)" | grep -qE "^${kube_context}$"; then
            _kubeconfig_tmp "${kube_context}" "${kube_namespace}"
            if [[ "${kube_context}" != "$(kubectl config current-context)" ]]; then
                echo "Switched to context \"${kube_context}\"."
            fi

            _kubeconfig_append "${KUBECONFIG_DEST_DIR}/${kubeconfig_file}"
        else
            echo "error: no context exists with name \"${kube_context}\"."
            return 1 2>/dev/null
            exit 1
        fi
    else
        KUBECONFIG=$(_kubeconfig_append) kubectl config get-contexts --no-headers=true -o name
    fi
}

# Switch namespace
kns () {
    local kube_namespace="${1:-default}"
    local kube_namespace_all=$(kubectl get namespaces -o=jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}')

    if [[ -n ${1} ]]; then
        # Only switch namespace if it exists.
        if echo "${kube_namespace_all}" | grep -qE "^${kube_namespace}$"; then
            kctx "$(kubectl config current-context)" "${kube_namespace}"
            kubectl config set-context --current --namespace="${kube_namespace}"
            echo "Switched to namespace \"${kube_namespace}\"."
        else
            echo "error: no namespace exists with name \"${kube_namespace}\"."
            return 1 2>/dev/null
            exit 1
        fi
    else
        echo "${kube_namespace_all}"
    fi
}

# Unset the active context.
kundo () {
    kubectl config unset current-context
}


